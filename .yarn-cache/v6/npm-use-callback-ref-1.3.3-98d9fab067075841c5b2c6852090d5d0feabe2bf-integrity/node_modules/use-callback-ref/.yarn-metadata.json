{
  "manifest": {
    "name": "use-callback-ref",
    "version": "1.3.3",
    "description": "The same useRef, but with callback",
    "main": "dist/es5/index.js",
    "jsnext:main": "dist/es2015/index.js",
    "module": "dist/es2015/index.js",
    "types": "dist/es5/index.d.ts",
    "module:es2019": "dist/es2019/index.js",
    "sideEffects": false,
    "scripts": {
      "dev": "lib-builder dev",
      "test": "jest",
      "test:ci": "jest --runInBand --coverage",
      "build": "lib-builder build && yarn size:report",
      "release": "yarn build && yarn test",
      "size": "npx size-limit",
      "size:report": "npx size-limit --json > .size.json",
      "lint": "lib-builder lint",
      "format": "lib-builder format",
      "update": "lib-builder update",
      "prepublish": "yarn build && yarn changelog",
      "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s",
      "changelog:rewrite": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/theKashey/use-callback-ref/"
    },
    "author": {
      "name": "theKashey",
      "email": "thekashey@gmail.com"
    },
    "license": "MIT",
    "dependencies": {
      "tslib": "^2.0.0"
    },
    "devDependencies": {
      "@size-limit/preset-small-lib": "^11.0.2",
      "size-limit": "^11.0.2",
      "@testing-library/jest-dom": "^6.1.5",
      "@testing-library/react": "^14.1.2",
      "@theuiteam/lib-builder": "^0.3.0",
      "jest-environment-jsdom": "^29.7.0"
    },
    "peerDependencies": {
      "@types/react": "*",
      "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
    },
    "peerDependenciesMeta": {
      "@types/react": {
        "optional": true
      }
    },
    "engines": {
      "node": ">=10"
    },
    "files": [
      "dist"
    ],
    "keywords": [
      "react",
      "hook",
      "useRef",
      "createRef",
      "merge refs"
    ],
    "husky": {
      "hooks": {
        "pre-commit": "lint-staged"
      }
    },
    "lint-staged": {
      "*.{ts,tsx}": [
        "prettier --write",
        "eslint --fix",
        "git add"
      ],
      "*.{js,css,json,md}": [
        "prettier --write",
        "git add"
      ]
    },
    "prettier": {
      "printWidth": 120,
      "trailingComma": "es5",
      "tabWidth": 2,
      "semi": true,
      "singleQuote": true
    },
    "_registry": "npm",
    "_loc": "/Users/schandel/Downloads/BPL Commander Project Management App (Copy)/.yarn-cache/v6/npm-use-callback-ref-1.3.3-98d9fab067075841c5b2c6852090d5d0feabe2bf-integrity/node_modules/use-callback-ref/package.json",
    "readmeFilename": "README.md",
    "readme": "<div align=\"center\">\n  <h1>ðŸ¤™ use-callback-ref ðŸ“ž</h1>\n  <br/>\n  The same `useRef` but it will callback: ðŸ“ž Hello! Your ref was changed!\n  <br/>\n    <a href=\"https://www.npmjs.com/package/use-callback-ref\">\n      <img src=\"https://img.shields.io/npm/v/use-callback-ref.svg?style=flat-square\" />\n    </a>\n    <a href=\"https://travis-ci.org/theKashey/use-callback-ref\">\n       <img alt=\"Travis\" src=\"https://img.shields.io/travis/theKashey/use-callback-ref/master.svg?style=flat-square\">\n    </a>\n    <a href=\"https://bundlephobia.com/result?p=use-callback-ref\">\n      <img src=\"https://img.shields.io/bundlephobia/minzip/use-callback-ref.svg\" alt=\"bundle size\">\n    </a> \n</div>\n\n---\n\n> Keep in mind that useRef doesn't notify you when its content changes.\n> Mutating the .current property doesn't cause a re-render.\n> If you want to run some code when React attaches or detaches a ref to a DOM node,\n> you may want to use ~~a callback ref instead~~ .... **useCallbackRef** instead.\n\nâ€“ [Hooks API Reference](https://reactjs.org/docs/hooks-reference.html#useref)\n\nRead more about `use-callback` pattern and use cases:\n\n- https://dev.to/thekashey/the-same-useref-but-it-will-callback-8bo\n\nThis library exposes helpers to handle any case related to `ref` _lifecycle_\n\n- `useCallbackRef` - react on a ref change (replacement for `useRef`)\n  - `createCallbackRef` - - low level version of `useCallbackRef`\n- `useMergeRefs` - merge multiple refs together creating a stable return ref\n  - `mergeRefs` - low level version of `useMergeRefs`\n- `useTransformRef` - transform one ref to another (replacement for `useImperativeHandle`)\n  - `transformRef` - low level version of `useTransformRef`\n- `useRefToCallback` - convert RefObject to an old callback-style ref\n  - `refToCallback` - low level version of `useRefToCallback`\n- `assignRef` - assign value to the ref, regardless it is RefCallback or RefObject\n\nAll functions are tree shakable, but even together it's **less then 300b**.\n\n# API\n\nðŸ’¡ Some commands are hooks based, and returns the same refs/functions every render.\nBut some are not, to be used in classes or non-react code.\n\n## useRef API\n\nðŸ¤” Use case: every time you have to react to ref change\n\nAPI is 99% compatible with React `createRef` and `useRef`, and just adds another argument - `callback`,\nwhich would be called on **ref update**.\n\n#### createCallbackRef - to replace React.createRef\n\n- `createCallbackRef(callback)` - would call provided `callback` when ref is changed.\n\n#### useCallbackRef - to replace React.useRef\n\n- `useCallbackRef(initialValue, callback)` - would call provided `callback` when ref is changed.\n\n> `callback` in both cases is `callback(newValue, oldValue)`. Callback would not be called if newValue and oldValue is the same.\n\n```js\nimport { useRef, createRef, useState } from 'react';\nimport { useCallbackRef, createCallbackRef } from 'use-callback-ref';\n\nconst Component = () => {\n  const [, forceUpdate] = useState();\n  // I dont need callback when ref changes\n  const ref = useRef(null);\n\n  // but sometimes - it could be what you need\n  const anotherRef = useCallbackRef(null, () => forceUpdate());\n\n  useEffect(() => {\n    // now it's just possible\n  }, [anotherRef.current]); // react to dom node change\n};\n```\n\nðŸ’¡ You can use `useCallbackRef` to convert RefObject into RefCallback, creating bridges between the old and the new code\n\n```js\n// some old component\nconst onRefUpdate = (newRef) => {...}\nconst refObject = useCallbackRef(null, onRefUpdate);\n// ...\n<SomeNewComponent ref={refObject}/>\n```\n\n## assignRef\n\nðŸ¤” Use case: every time you need to assign ref manually, and you dont know the shape of the ref\n\n`assignRef(ref, value)` - assigns `values` to the `ref`. `ref` could be RefObject or RefCallback.\n\n```\nðŸš« ref.current = value // what if it's a callback-ref?\nðŸš« ref(value) // but what if it's a object ref?\n\nimport {assignRef} from \"use-callback-ref\";\nâœ… assignRef(ref, value);\n```\n\n## useTransformRef (to replace React.useImperativeHandle)\n\nðŸ¤” Use case: ref could be different.\n`transformRef(ref, tranformer):Ref` - return a new `ref` which would propagate all changes to the provided `ref` with applied `transform`\n\n```js\n// before\nconst ResizableWithRef = forwardRef((props, ref) => <Resizable {...props} ref={(i) => i && ref(i.resizable)} />);\n\n// after\n\nconst ResizableWithRef = forwardRef((props, ref) => (\n  <Resizable {...props} ref={transformRef(ref, (i) => (i ? i.resizable : null))} />\n));\n```\n\n## refToCallback\n\n`refToCallback(ref: RefObject): RefCallback` - for compatibility between the old and the new code.\nFor the compatibility between `RefCallback` and RefObject use `useCallbackRef(undefined, callback)`\n\n## useMergeRefs\n\n`mergeRefs(refs: arrayOfRefs, [defaultValue]):ReactMutableRef` - merges a few refs together\n\nWhen developing low level UI components, it is common to have to use a local ref but also support an external one using React.forwardRef. Natively, React does not offer a way to set two refs inside the ref property. This is the goal of this small utility.\n\n```js\nimport React from 'react';\nimport { useMergeRefs } from 'use-callback-ref';\n\nconst MergedComponent = React.forwardRef((props, ref) => {\n  const localRef = React.useRef();\n  // ...\n  // both localRef and ref would be populated with the `ref` to a `div`\n  return <div ref={useMergeRefs([localRef, ref])} />;\n});\n```\n\nðŸ’¡ - `useMergeRefs` will always give you the same return, and you don't have to worry about `[localRef, ref]` unique every render.\n\n## mergeRefs\n\n`mergeRefs(refs: arrayOfRefs, [defaultValue]):ReactMutableRef` - merges a few refs together\nis a non-hook based version. Will produce the new `ref` every run, causing the old one to unmount, and be _populated_ with the `null` value.\n\n> mergeRefs are based on https://github.com/smooth-code/react-merge-refs, just exposes a RefObject, instead of a callback\n\n`mergeRefs` are \"safe\" to use as a part of other hooks-based commands, but don't forget - it returns a new object every call.\n\n# Similar packages:\n\n- [apply-ref](https://github.com/mitchellhamilton/apply-ref) - `applyRefs` is simular to `mergeRef`, `applyRef` is similar to `assignRef`\n- [useForkRef](https://react-hooks.org/docs/use-fork-ref) - `useForkRef` is simular to `useMergeRefs`, but accepts only two arguments.\n- [react-merge-refs](https://github.com/gregberge/react-merge-refs) - `merge-refs` is simular to `useMergeRefs`, but not a hook and does not provide \"stable\" reference.\n\n---\n\n> Is it a rocket science? No, `RefObject` is no more than `{current: ref}`, and `use-callback-ref` is no more than `getter` and `setter` on that field.\n\n# License\n\nMIT\n",
    "licenseText": "MIT License\n\nCopyright (c) 2017 Anton Korzunov\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/use-callback-ref/-/use-callback-ref-1.3.3.tgz#98d9fab067075841c5b2c6852090d5d0feabe2bf",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/use-callback-ref/-/use-callback-ref-1.3.3.tgz",
    "hash": "98d9fab067075841c5b2c6852090d5d0feabe2bf",
    "integrity": "sha512-jQL3lRnocaFtu3V00JToYz/4QkNWswxijDaCVNZRiRTO3HQDLsdu1ZtmIUvV4yPp+rvWm5j0y0TG/S61cuijTg==",
    "registry": "npm",
    "packageName": "use-callback-ref",
    "cacheIntegrity": "sha512-jQL3lRnocaFtu3V00JToYz/4QkNWswxijDaCVNZRiRTO3HQDLsdu1ZtmIUvV4yPp+rvWm5j0y0TG/S61cuijTg== sha1-mNn6sGcHWEHFssaFIJDV0P6r4r8="
  },
  "registry": "npm",
  "hash": "98d9fab067075841c5b2c6852090d5d0feabe2bf"
}